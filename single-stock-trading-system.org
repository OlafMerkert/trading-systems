# -*- ispell-dictionary: "en_GB"

#+TITLE:     Basic trading system for a single stock
#+AUTHOR:    Olaf Merkert
#+EMAIL:     olaf@m-merkert.de
#+LANGUAGE:  en
#+PROPERTY:  header-args :results silent :tangle yes
#+TODO: TODO | DONE

* TODO Introduction
We wish to develop a basic trading system, which can watch a single stock and keep track of a single position an said stock.

Our language of choice is Common Lisp, we start by loading the required dependencies.
#+begin_src lisp
(ql:quickload '(ol-utils drakma cl-csv parse-number eazy-gnuplot lisp-matrix))
#+end_src

Some bug in lisp matrix requires that we import all its symbols into our package. There is one conflict with the =copy= function from =ol-utils=, though.
#+begin_src lisp
(use-package :lisp-matrix)
#+end_src
* DONE Importing data
We begin by downloading the CSV data and parsing it. Notice that months are given first and use numbers 0-11. For days, the usual numbering 1-31 is used.
#+begin_src lisp
(defpar *stock-csv-data*
        (cl-csv:read-csv
         (drakma:http-request "http://chart.finance.yahoo.com/table.csv?s=SPY&a=0&b=1&c=2000&d=11&e=31&f=2010&g=d&ignore=.csv"
                              :want-stream t :close t)))
#+end_src

#+begin_src lisp :results replace value 
(subseq *stock-csv-data* 0 10)
#+end_src

#+RESULTS:
|       Date |       Open |       High |        Low |      Close |    Volume |  Adj Close |
| 2010-12-31 | 125.529999 | 125.870003 | 125.330002 |     125.75 |  91218900 | 111.772075 |
| 2010-12-30 | 125.800003 | 126.129997 | 125.529999 | 125.720001 |  76616900 |  111.74541 |
| 2010-12-29 | 125.980003 | 126.199997 | 125.900002 | 125.919998 |  58033100 | 111.923176 |
| 2010-12-28 | 125.900002 | 125.949997 |     125.50 | 125.830002 |  55309100 | 111.843184 |
| 2010-12-27 | 125.129997 | 125.769997 | 125.040001 | 125.650002 |  58126000 | 111.683192 |
| 2010-12-23 | 125.639999 | 125.779999 | 125.290001 | 125.599998 |  70053700 | 111.638747 |
| 2010-12-22 | 125.480003 |     125.82 | 125.410004 | 125.779999 |  78878100 | 111.798739 |
| 2010-12-21 | 124.989998 | 125.470001 | 124.870003 | 125.389999 |  94965500 |  111.45209 |
| 2010-12-20 | 124.639999 | 124.900002 | 123.980003 | 124.599998 | 119085500 | 110.749903 |

The data is still of type string. We have 7 columns, but we only need Open, High, Low, Close and Volume.

We define a new class to hold this data. We keep each column in a separate array/vector.
#+begin_src lisp
(defclass/f stock ()
  (stock-ticker
   stock-date
   stock-open stock-high stock-low stock-close stock-volume))

(defmethod print-object ((stock stock) stream)
  (print-unreadable-object (stock stream :type t)
    (with-accessors ((stock-ticker stock-ticker)
                     (stock-date stock-date))
        stock
      (format stream "~a LEN: ~a" stock-ticker (length stock-date))))
  stock)

(defun csv->stock (ticker stock-csv-data)
  (iter (for event in (rest stock-csv-data)) ; remove header
        (collect (elt event 0) into stock-date result-type vector)
        (collect (parse-number:parse-number (elt event 1)) into stock-open result-type vector)
        (collect (parse-number:parse-number (elt event 2)) into stock-high result-type vector)
        (collect (parse-number:parse-number (elt event 3)) into stock-low result-type vector)
        (collect (parse-number:parse-number (elt event 4)) into stock-close result-type vector)
        (collect (parse-number:parse-number (elt event 5)) into stock-volume result-type vector)
        (finally (return (make-instance 'stock
                                        :stock-ticker ticker
                                        :stock-date stock-date
                                        :stock-open stock-open
                                        :stock-high stock-high
                                        :stock-low stock-low
                                        :stock-close stock-close
                                        :stock-volume stock-volume)))))

(defpar *current-stock* (csv->stock "SPY" *stock-csv-data*))
#+end_src
For now, we ignore the concrete dates and just use integers to refer to dates. Note that higher index means earlier date.
** DONE Subclass for filtering to past data
For our trading algorithm, we need to restrict our view to the past. Sometimes it may be useful to generally restrict to some time interval.
#+begin_src lisp
(defclass/f stock-subseq (stock)
  (parent start end))

(defun stock-subseq (stock start &optional end)
  (make-instance 'stock-subseq :parent stock :start start :end end))

(defmethod stock-ticker ((stock-subseq stock-subseq))
  (stock-ticker (parent stock-subseq)))

;; bind multi copies the definition for stock-date for the other slots
(bind-multi ((stock-date stock-date stock-open stock-high stock-low stock-close stock-volume))
  (defmethod stock-date ((stock-subseq stock-subseq))
    (subseq (stock-date (parent stock-subseq)) (start stock-subseq) (end stock-subseq))))
#+end_src

* TODO Trading system
We need to implement orders. For now we restrict to the single stock case.

+ An order is long or short, on some specific stock
+ The order starts at open, and finishes at close
+ for each we have a starting day
+ starting and finishing both return a number: positive if adding to your account (selling), negative if deducting (buying). Transaction cost is factored in automatically.
+ Before committing to an order, we need to check we have the money.
** DONE Orders
The lifecycle of an order is as follows:
+ Decide on the stock and whether to long or short it
+ Then try to open the order, see if we can afford it. Possibly decrease the volume.
+ Finally close the order. For short orders, we also need to check if we actually can afford it.
#+begin_src lisp
(defclass/f order ()
  (order-stock order-type order-start order-end order-volume))

(defun order-create (stock &optional (order-type :long))
  (make-instance 'order
                 :order-stock stock :order-type order-type
                 :order-start nil :order-end nil :order-volume nil))
#+end_src

For the dates we just use integers, referring to indices for the =stock= datastructure. We store the date in a special variable. Both =order-open= and =order-close= return a number which represents the balance change of our account. This includes already the transaction costs (which depend on =order-volume= and current stock value).

Note we always open orders at "open", and always close orders at "close".

Currently slippage is not modeled, I am not even sure it would factor into this code.
#+begin_src lisp
(defvar *current-date* 0)
(defpar *transaction-cost-factor* 0.0025)

(defmethod order-open ((order order) volume)
  ;; check if volume is available for long
  (when (and (eql (order-type order) :long)
             (< (aref (stock-volume (order-stock order)) *current-date*) volume))
    ;; todo signal something
    (return-from order-open nil))
  (setf (order-start order) *current-date*
        (order-volume order) volume)
  ;; buy/sell at opening time
  (let ((amount (* (if (eql (order-type order) :long) -1 1)
                   volume (aref (stock-open (order-stock order)) *current-date*))))
    ;; pay transaction fee
    (- amount (* *transaction-cost-factor* amount))))

(defmethod order-close ((order order))
  ;; check if volume is available for short
  (when (and (not (eql (order-type order) :long))
             (< (aref (stock-volume (order-stock order)) *current-date*) (order-volume order)))
    ;; todo signal something
    (return-from order-close nil))
  (setf (order-end order) *current-date*)
  ;; buy/sell at closing time
  (let ((amount (* (if (eql (order-type order) :long) 1 -1)
                   (order-volume order) (aref (stock-close (order-stock order)) *current-date*))))
    ;; pay transaction fee
    (- amount (* *transaction-cost-factor* amount))))
#+end_src

We add a function that determines the maximal volume available to buy for a given amount of money. For each piece of stock we need to spend market price and transaction fee. We assume we cannot buy part of a stock, so volume should always be an integer.
#+begin_src lisp
(defmethod stock-available-volume ((stock stock) time amount)
  (min (aref (stock-volume stock) *current-date*)
       (floor amount
              (* (aref (if (eql time :open) (stock-open stock) (stock-close stock)) *current-date*)
                 (+ 1 *transaction-cost-factor*)))))

(defmethod stock-available-volume ((stock stock) (order order) amount)
  (assert (eql stock (order-stock order)))
  (stock-available-volume stock (if (eql (order-type order) :long) :open :close) amount))
#+end_src

** DONE Trading
For actual trading, we need to keep track of
+ current order
+ current balance
and maybe also collect some statistics. We model this with a trader object. A trader can only have one position at a time. We assume the trader is not completely stupid, so he will avoid always negative balance -- until time is over, and he may be forced to close a shorted position.
#+begin_src lisp
(defclass/f trader ()
  (trader-stock
   trader-balance
   (current-order :initarg :current-order
                  :initform nil
                  :accessor current-order)))

(defmethod busy-p ((trader trader))
  (current-order trader))

(defmethod short ((trader trader) part)
  ;; here we need any positive number. keep in mind that anything
  ;; significantly larger than 1 is probably rather stupid.
  (assert (<= 0 part))
  (unless (busy-p trader)
    (with-accessors ((current-order current-order)) trader
      (setf current-order (order-create (trader-stock trader) :short))
      (let* ((amount (* part (trader-balance trader)))
             ;; don't do stupid stuff like go over available volume
             (volume (stock-available-volume (trader-stock trader) :open amount))
             ;; see if we can afford it
             (new-balance (+ (trader-balance trader)
                             (order-open current-order volume))))
        (if (< new-balance 0)
            ;; abort
            (progn
              (setf current-order nil)
              nil)
            ;; update balance
            (progn
              (setf (trader-balance trader) new-balance)
              t))))))

(defmethod long ((trader trader) part)
  ;; for this type of trade, we need a number between 0 and 1
  (assert (<= 0 part 1))
  (unless (busy-p trader)
    (with-accessors ((current-order current-order)) trader
      (setf current-order (order-create (trader-stock trader) :long))
      (let* ((amount (* part (trader-balance trader)))
             ;; don't do stupid stuff like go over available volume
             (volume (stock-available-volume (trader-stock trader) :open amount))
             ;; see if we can afford it
             (new-balance (+ (trader-balance trader)
                             (order-open current-order volume))))
        (if (< new-balance 0)
            ;; abort
            (progn
              (setf current-order nil)
              nil)
            ;; update balance
            (progn
              (setf (trader-balance trader) new-balance)
              t))))))

(defmethod conclude ((trader trader) &optional final)
  (when (busy-p trader)
    (with-accessors ((current-order current-order)) trader
      (let ((amount (order-close current-order)))
        ;; possibly `amount' is nil, if not enough volume is available
        (when amount
          (let ((new-balance (+ (trader-balance trader) amount)))
            (if (and (< new-balance 0) (not final))
                ;; abort
                (progn
                  (setf current-order nil)
                  nil)
                ;; update balance
                (progn
                  (setf (trader-balance trader) new-balance)
                  t))))))))
#+end_src

** DONE Reporting for trading
One important feature is still missing from the =trader= class: keeping track of which orders went through and how the balance evolved over time. To implement this, we hook into balance changes and watch for successfully concluded orders.
#+begin_src lisp
(defclass/f reporting-trader (trader)
  (balance-report
   order-list))

(defmethod initialize-instance :after ((reporting-trader reporting-trader) &key)
  ;; order-list is a simple list
  (setf (order-list reporting-trader) nil)
  ;; balance-report should be an array with length matching the stock history
  (let ((history-length (length (stock-date (trader-stock reporting-trader)))))
    (setf (balance-report reporting-trader)
          (make-array history-length :initial-element nil))
    ;; we initialise the last entry (first date) with initial balance
    (setf (aref (balance-report reporting-trader) (- history-length 1))
          (trader-balance reporting-trader))))

;; store data everytime the balance changes
(defmethod (setf trader-balance) :after (value (reporting-trader reporting-trader))
  (setf (aref (balance-report reporting-trader) *current-date*) value))

;; we find out if a order was successful when it concludes
(defmethod conclude :around ((reporting-trader reporting-trader) &optional final)
  (let ((order (current-order reporting-trader))
        (result (call-next-method)))
    (when result
      (push order (order-list reporting-trader)))
    result))
#+end_src

If we do not trade every day, then there will be gaps in the =balance-report= vector. We need to fill these up, by copying the balance from the previous day. For convenience, we immediately return the vector.

The order list should not require any further fixup.
#+begin_src lisp
(defmethod prepare-report ((reporting-trader reporting-trader))
  (with-accessors ((balance-report balance-report)) reporting-trader
    (let1 (history-length (length balance-report))
      ;; make sure the initial balance is present
      (assert (aref balance-report (- history-length 1)))
      (do ((i (- history-length 2) (- i 1))
           (j (- history-length 1) i))
          ((< i 0) balance-report)
        (unless (aref balance-report i)
          (setf (aref balance-report i) (aref balance-report j)))))))
#+end_src
** DONE Accessing past data
The trading algorithm should be given only data from the past. We define some methods that take care of this filtering. We can only restrict the number of data points returned.
#+begin_src lisp
(defmethod past-data ((stock stock) &optional count)
  (stock-subseq stock (+ *current-date* 1) (if count (+ *current-date* count 1))))

(defmethod past-data ((stock-subseq stock-subseq) &optional count)
  (let ((start (max (+ *current-date* 1) (start stock-subseq))))
    (stock-subseq (parent stock-subseq) start
                  (if count
                      (min (+ start count) (end stock-subseq))
                      (end stock-subseq)))))
#+end_src
* TODO Basic trading algorithm
The idea for my trading algorithm is to do something a little bit more complicated thing than a moving average: Trying to fit a parabola to some moving frame of data. This should give some information also on the curvature, and maybe we can even predict or at least anticipate extrema.
** TODO Fitting quadratic functions
The standard method for fitting a polynomial to some data is using Least-Squares. It seems what we need is available in [[https://github.com/blindglobe/lisp-matrix/tree/master][lisp-matrix]], namely a QR decomposition.

#+begin_src lisp
(defun least-squares-quadratic (data &optional (polynomial-degree 2))
  (check-type data vector)
  (let* ((len (length data))
         (matrix (make-matrix len (+ 1 polynomial-degree) :initial-element (coerce 1 'double-float))))
    ;; fill the matrix
    (dotimes (j polynomial-degree)
      (dotimes (i len)
        ;; a row is built by multiplying the previous row with the data
        (setf (mref matrix i (+ 1 j)) (* (mref matrix i j) (aref data i)))))
    ;; do a QR decomposition
    (lisp-matrix::factorize (transpose-matrix matrix) :by :qr)))

(least-squares-quadratic (vector 0 1 4))
;; TODO not working yet 
#+end_src
** TODO Parabola analysis
* TODO Data visualisation
** DONE Plotting financial data
#+begin_src lisp
(defun gnuplot-date-tranform (dashed-date)
  (format nil "~A/~A/~A"
          (subseq dashed-date 5 7)
          (subseq dashed-date 8 10)
          (subseq dashed-date 0 4)))

(defgeneric plot-object (object))

(defmethod plot-object ((stock stock))
  (eazy-gnuplot:plot (lambda ()
                       (map nil (lambda (d o l h c)
                                  ;; date open low high close
                                  (format t "~&~A ~A ~A ~A ~A" (gnuplot-date-tranform d) o l h c))
                            (stock-date stock)
                            (stock-open stock)
                            (stock-low stock)
                            (stock-high stock)
                            (stock-close stock)))
                     :using '(0 2 3 4 5)
                     :with 'financebars))

(defun plot* (output &rest objects)
  (eazy-gnuplot:with-plots (*standard-output* :debug nil)
    (eazy-gnuplot:gp-setup :terminal '(pngcairo) :output output :bars 2)
    (dolist (o objects)
      (plot-object o)))
  output)
#+end_src

#+begin_src lisp
(plot* "plot-1.png" *current-stock*)
(plot* "plot-2.png" (stock-subseq *current-stock* 2000))
#+end_src

[[file:plot-1.png]]

file:plot-2.png

*** DONE fix date format for gnuplot

*** TODO fix date printing

*** TODO fix timeline direction

** TODO Plotting trader performance
